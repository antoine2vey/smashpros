### This file was generated by Nexus Schema
### Do not make changes to this file directly


type AuthPayload {
  accessToken: String
  refreshToken: String
}

type Battle {
  id: ID!
  initiator: User
  initiator_character: Character
  initiator_vote: User
  opponent: User
  opponent_character: Character
  opponent_vote: User
  winner: User
  winner_id: String
}

type Character {
  id: ID!
  name: String!
  picture: String!
  users: [User!]!
}

type Crew {
  admin: User!
  banner: String!
  icon: String!
  id: ID!
  members: [User!]!
  name: String!
  prefix: String!
  waiting_members: [User!]!
}

input CrewCreationPayload {
  banner: Upload!
  icon: Upload!
  name: String!
  prefix: String!
}

enum CrewUpdateActionEnum {
  ACCEPT
  DENY
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

type Event {
  event_id: Int!
  id: ID!
  name: String!
  num_attendees: Int!
  tier: String!
  tournament: Tournament!
  valid: Boolean!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type Match {
  amount: Int
  battles: [Battle!]!
  id: ID!
  initiator: User
  initiator_wins: Int!
  is_moneymatch: Boolean!
  opponent: User
  opponent_wins: Int!
  state: MatchState!
  total_matches: Int!
  winner: User
  winner_id: String
}

type MatchConnection {
  edges: [MatchEdge]
  pageInfo: PageInfo!
  totalCount: Int!
}

type MatchEdge {
  cursor: String!
  node: Match
}

enum MatchState {
  CHARACTER_CHOICE
  FINISHED
  HOLD
  PLAYING
  REFUSED
}

type Mutation {
  askPasswordReset(email: String!): String
  checkUserIn(participant: ID!, tournament: ID!): Boolean
  createCrew(payload: CrewCreationPayload!): Crew
  favoriteTournament(id: ID!, unfavorite: Boolean = false): Boolean
  joinCrew(id: ID!): Crew
  kickMember(id: ID!): User
  leaveCrew: Crew
  login(email: String!, password: String!): AuthPayload
  participateTournament(id: ID!, unparticipate: Boolean): Tournament
  passwordReset(code: String!, confirmPassword: String!, password: String!): Boolean
  refresh(refreshToken: String!): RefreshPayload
  register(payload: UserRegisterPayload!): User
  sendMatchInvite(amount: Int, isMoneymatch: Boolean, to: ID!, totalMatches: Int!, tournament: ID): Match
  setOnline(online: Boolean!): User
  synchronizeTournaments: [Tournament]
  transferCrewOwnership(to: ID!): Crew
  updateBattle(character: ID, id: ID!, vote: ID): Battle
  updateMatch(id: ID!, state: MatchState!): Match
  updateMember(action: CrewUpdateActionEnum!, id: ID!): Crew
  updateProfile(payload: UserUpdatePayload!): User
  userEnteredTournament(tournament: ID!): User
  userLeftTournament(tournament: ID!): User
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Query {
  characters: [Character]
  crew(id: ID): Crew
  crews: [Crew]
  match(id: ID!): Match
  matches(after: String, before: String, first: Int, last: Int): MatchConnection
  suggestedName(slug: String!): SuggestedName
  tournament(id: ID!): Tournament
  tournaments(after: String, before: String, filters: TournamentsFilter, first: Int, last: Int): TournamentConnection
  user(id: ID): User
  users(after: String, before: String, filters: UserFilter!, first: Int, last: Int): UserConnection
}

type RefreshPayload {
  accessToken: String
}

input RegisterPayload {
  success: Boolean
}

type Role {
  id: ID!
  name: RoleEnum!
}

enum RoleEnum {
  ADMIN
  CREW_ADMIN
  TOURNAMENT_ORGANIZER
  USER
}

type Subscription {
  onBattleUpdate(id: ID): Battle
  onMatchUpdate(id: ID!): Match
  onUserJoinMatch(id: ID!): User
  onUserLeftMatch(id: ID!): User
  userEnteredTournament: User!
  userLeftTournament: User!
}

type SuggestedName {
  profilePicture: String
  smashGGPlayerId: Int!
  smashGGUserId: Int!
  tag: String!
}

type Tournament {
  city: String
  country_code: String!
  created_at: DateTime
  currency: String!
  end_at: DateTime
  event_registration_closes_at: DateTime
  events: [Event!]!
  favorited_by: [User!]!
  has_offline_events: Boolean
  id: ID!
  images: [String!]!
  is_registration_open: Boolean
  is_started: Boolean!
  lat: Float
  lng: Float
  name: String!
  num_attendees: Int
  participants(after: String, before: String, characters: [ID!], first: Int, last: Int): UserConnection
  slug: String!
  start_at: DateTime
  state: Int!
  tournament_id: Int!
  venue_address: String
  venue_name: String
}

type TournamentConnection {
  edges: [TournamentEdge]
  pageInfo: PageInfo!
  totalCount: Int!
}

type TournamentEdge {
  cursor: String!
  node: Tournament
}

input TournamentQuery {
  id: ID
  player: String
}

input TournamentsFilter {
  endDate: DateTime
  startDate: DateTime
  zone: ID
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

type User {
  allow_notifications: Boolean!
  allow_searchability: Boolean!
  characters: [Character!]!
  created_at: DateTime!
  crew: Crew
  email: String!
  favorited_tournaments: [Tournament!]!
  id: ID!
  in_match: Boolean!
  in_tournament: Boolean!
  nextTournament: Tournament
  profile_picture: String
  roles: [Role!]!
  smashgg_player_id: Int
  smashgg_slug: String
  tag: String!
  tournaments: [Tournament!]!
  tournaments_organizer: [Tournament!]!
  twitch_username: String
  twitter_username: String
  updated_at: DateTime!
  waiting_crew: Crew
}

type UserConnection {
  edges: [UserEdge]
  pageInfo: PageInfo!
  totalCount: Int!
}

type UserEdge {
  cursor: String!
  node: User
}

input UserFilter {
  characters: [ID!]
  tag: String
  tournament: ID
}

input UserRegisterPayload {
  characters: [ID!]!
  email: String!
  password: String!
  profilePicture: Upload!
  smashGGPlayerId: Int
  smashGGSlug: String
  smashGGUserId: Int
  tag: String!
  twitchUsername: String
  twitterUsername: String
}

input UserUpdatePayload {
  characters: [ID!]!
  email: String!
  password: String!
  profilePicture: Upload
  smashGGPlayerId: Int
  smashGGSlug: String
  smashGGUserId: Int
  tag: String!
  twitchUsername: String
  twitterUsername: String
}
